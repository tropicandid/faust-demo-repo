{"version":3,"sources":["@wordpress/block-library/src/query/edit/inspector-controls/taxonomy-controls.js"],"names":["getTermIdByTermValue","terms","termValue","termId","id","find","term","name","termValueLower","toLocaleLowerCase","useTaxonomyTerms","slug","select","coreStore","getEntityRecords","context","per_page","MAX_FETCHED_TERMS","TaxonomyControls","onChange","query","postType","taxQuery","taxonomies","length","map","taxonomy","value","handleChange","newTermIds","TaxonomyItem","onTermsChange","newTermValues","termIds","Set","add","Array","from","taxQueryValue","t","filter","Boolean"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { FormTokenField } from '@wordpress/components';\nimport { useSelect } from '@wordpress/data';\nimport { store as coreStore } from '@wordpress/core-data';\n\n/**\n * Internal dependencies\n */\nimport { useTaxonomies } from '../../utils';\nimport { MAX_FETCHED_TERMS } from '../../constants';\n\n// Helper function to get the term id based on user input in terms `FormTokenField`.\nconst getTermIdByTermValue = ( terms, termValue ) => {\n\t// First we check for exact match by `term.id` or case sensitive `term.name` match.\n\tconst termId =\n\t\ttermValue?.id || terms.find( ( term ) => term.name === termValue )?.id;\n\tif ( termId ) {\n\t\treturn termId;\n\t}\n\n\t/**\n\t * Here we make an extra check for entered terms in a non case sensitive way,\n\t * to match user expectations, due to `FormTokenField` behaviour that shows\n\t * suggestions which are case insensitive.\n\t *\n\t * Although WP tries to discourage users to add terms with the same name (case insensitive),\n\t * it's still possible if you manually change the name, as long as the terms have different slugs.\n\t * In this edge case we always apply the first match from the terms list.\n\t */\n\tconst termValueLower = termValue.toLocaleLowerCase();\n\treturn terms.find(\n\t\t( term ) => term.name.toLocaleLowerCase() === termValueLower\n\t)?.id;\n};\n\nconst useTaxonomyTerms = ( slug ) => {\n\treturn useSelect(\n\t\t( select ) => {\n\t\t\tconst terms = select( coreStore ).getEntityRecords(\n\t\t\t\t'taxonomy',\n\t\t\t\tslug,\n\t\t\t\t{ context: 'view', per_page: MAX_FETCHED_TERMS }\n\t\t\t);\n\t\t\treturn { terms };\n\t\t},\n\t\t[ slug ]\n\t);\n};\n\nexport function TaxonomyControls( { onChange, query } ) {\n\tconst { postType, taxQuery } = query;\n\n\tconst taxonomies = useTaxonomies( postType );\n\tif ( ! taxonomies || taxonomies.length === 0 ) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t{ taxonomies.map( ( taxonomy ) => {\n\t\t\t\tconst value = taxQuery?.[ taxonomy.slug ] || [];\n\t\t\t\tconst handleChange = ( newTermIds ) =>\n\t\t\t\t\tonChange( {\n\t\t\t\t\t\ttaxQuery: {\n\t\t\t\t\t\t\t...taxQuery,\n\t\t\t\t\t\t\t[ taxonomy.slug ]: newTermIds,\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\treturn (\n\t\t\t\t\t<TaxonomyItem\n\t\t\t\t\t\tkey={ taxonomy.slug }\n\t\t\t\t\t\ttaxonomy={ taxonomy }\n\t\t\t\t\t\tvalue={ value }\n\t\t\t\t\t\tonChange={ handleChange }\n\t\t\t\t\t/>\n\t\t\t\t);\n\t\t\t} ) }\n\t\t</>\n\t);\n}\nfunction TaxonomyItem( { taxonomy, value, onChange } ) {\n\tconst { terms } = useTaxonomyTerms( taxonomy.slug );\n\tif ( ! terms?.length ) {\n\t\treturn null;\n\t}\n\n\tconst onTermsChange = ( newTermValues ) => {\n\t\tconst termIds = new Set();\n\t\tfor ( const termValue of newTermValues ) {\n\t\t\tconst termId = getTermIdByTermValue( terms, termValue );\n\t\t\tif ( termId ) {\n\t\t\t\ttermIds.add( termId );\n\t\t\t}\n\t\t}\n\n\t\tonChange( Array.from( termIds ) );\n\t};\n\n\t// Selects only the existing term ids in proper format to be\n\t// used in `FormTokenField`. This prevents the component from\n\t// crashing in the editor, when non existing term ids were provided.\n\tconst taxQueryValue = value\n\t\t.map( ( termId ) => terms.find( ( t ) => t.id === termId ) )\n\t\t.filter( Boolean )\n\t\t.map( ( term ) => ( { id: term.id, value: term.name } ) );\n\n\treturn (\n\t\t<div className=\"block-library-query-inspector__taxonomy-control\">\n\t\t\t<FormTokenField\n\t\t\t\tlabel={ taxonomy.name }\n\t\t\t\tvalue={ taxQueryValue }\n\t\t\t\tsuggestions={ terms.map( ( t ) => t.name ) }\n\t\t\t\tonChange={ onTermsChange }\n\t\t\t\t__experimentalShowHowTo={ false }\n\t\t\t/>\n\t\t</div>\n\t);\n}\n"]}
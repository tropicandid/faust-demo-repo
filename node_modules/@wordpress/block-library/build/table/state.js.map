{"version":3,"sources":["@wordpress/block-library/src/table/state.js"],"names":["INHERITED_COLUMN_ATTRIBUTES","createTable","rowCount","columnCount","body","Array","from","length","map","cells","content","tag","getFirstRow","state","isEmptyTableSection","head","foot","getCellAttribute","cellLocation","attributeName","sectionName","rowIndex","columnIndex","updateSelectedCell","selection","updateCell","tableSections","selectionSectionName","selectionRowIndex","section","row","cellAttributes","isCellSelected","type","insertRow","firstRow","cellCount","undefined","slice","_","index","firstCellInColumn","inheritedAttributes","deleteRow","filter","insertColumn","isEmptyRow","deleteColumn","cell","toggleSection","every"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { get, mapValues, pick } from 'lodash';\n\nconst INHERITED_COLUMN_ATTRIBUTES = [ 'align' ];\n\n/**\n * Creates a table state.\n *\n * @param {Object} options\n * @param {number} options.rowCount    Row count for the table to create.\n * @param {number} options.columnCount Column count for the table to create.\n *\n * @return {Object} New table state.\n */\nexport function createTable( { rowCount, columnCount } ) {\n\treturn {\n\t\tbody: Array.from( { length: rowCount } ).map( () => ( {\n\t\t\tcells: Array.from( { length: columnCount } ).map( () => ( {\n\t\t\t\tcontent: '',\n\t\t\t\ttag: 'td',\n\t\t\t} ) ),\n\t\t} ) ),\n\t};\n}\n\n/**\n * Returns the first row in the table.\n *\n * @param {Object} state Current table state.\n *\n * @return {Object} The first table row.\n */\nexport function getFirstRow( state ) {\n\tif ( ! isEmptyTableSection( state.head ) ) {\n\t\treturn state.head[ 0 ];\n\t}\n\tif ( ! isEmptyTableSection( state.body ) ) {\n\t\treturn state.body[ 0 ];\n\t}\n\tif ( ! isEmptyTableSection( state.foot ) ) {\n\t\treturn state.foot[ 0 ];\n\t}\n}\n\n/**\n * Gets an attribute for a cell.\n *\n * @param {Object} state         Current table state.\n * @param {Object} cellLocation  The location of the cell\n * @param {string} attributeName The name of the attribute to get the value of.\n *\n * @return {*} The attribute value.\n */\nexport function getCellAttribute( state, cellLocation, attributeName ) {\n\tconst { sectionName, rowIndex, columnIndex } = cellLocation;\n\treturn get( state, [\n\t\tsectionName,\n\t\trowIndex,\n\t\t'cells',\n\t\tcolumnIndex,\n\t\tattributeName,\n\t] );\n}\n\n/**\n * Returns updated cell attributes after applying the `updateCell` function to the selection.\n *\n * @param {Object}   state      The block attributes.\n * @param {Object}   selection  The selection of cells to update.\n * @param {Function} updateCell A function to update the selected cell attributes.\n *\n * @return {Object} New table state including the updated cells.\n */\nexport function updateSelectedCell( state, selection, updateCell ) {\n\tif ( ! selection ) {\n\t\treturn state;\n\t}\n\n\tconst tableSections = pick( state, [ 'head', 'body', 'foot' ] );\n\tconst { sectionName: selectionSectionName, rowIndex: selectionRowIndex } =\n\t\tselection;\n\n\treturn mapValues( tableSections, ( section, sectionName ) => {\n\t\tif ( selectionSectionName && selectionSectionName !== sectionName ) {\n\t\t\treturn section;\n\t\t}\n\n\t\treturn section.map( ( row, rowIndex ) => {\n\t\t\tif ( selectionRowIndex && selectionRowIndex !== rowIndex ) {\n\t\t\t\treturn row;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcells: row.cells.map( ( cellAttributes, columnIndex ) => {\n\t\t\t\t\tconst cellLocation = {\n\t\t\t\t\t\tsectionName,\n\t\t\t\t\t\tcolumnIndex,\n\t\t\t\t\t\trowIndex,\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ! isCellSelected( cellLocation, selection ) ) {\n\t\t\t\t\t\treturn cellAttributes;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updateCell( cellAttributes );\n\t\t\t\t} ),\n\t\t\t};\n\t\t} );\n\t} );\n}\n\n/**\n * Returns whether the cell at `cellLocation` is included in the selection `selection`.\n *\n * @param {Object} cellLocation An object containing cell location properties.\n * @param {Object} selection    An object containing selection properties.\n *\n * @return {boolean} True if the cell is selected, false otherwise.\n */\nexport function isCellSelected( cellLocation, selection ) {\n\tif ( ! cellLocation || ! selection ) {\n\t\treturn false;\n\t}\n\n\tswitch ( selection.type ) {\n\t\tcase 'column':\n\t\t\treturn (\n\t\t\t\tselection.type === 'column' &&\n\t\t\t\tcellLocation.columnIndex === selection.columnIndex\n\t\t\t);\n\t\tcase 'cell':\n\t\t\treturn (\n\t\t\t\tselection.type === 'cell' &&\n\t\t\t\tcellLocation.sectionName === selection.sectionName &&\n\t\t\t\tcellLocation.columnIndex === selection.columnIndex &&\n\t\t\t\tcellLocation.rowIndex === selection.rowIndex\n\t\t\t);\n\t}\n}\n\n/**\n * Inserts a row in the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {string} options.sectionName Section in which to insert the row.\n * @param {number} options.rowIndex    Row index at which to insert the row.\n * @param {number} options.columnCount Column count for the table to create.\n *\n * @return {Object} New table state.\n */\nexport function insertRow( state, { sectionName, rowIndex, columnCount } ) {\n\tconst firstRow = getFirstRow( state );\n\tconst cellCount =\n\t\tcolumnCount === undefined\n\t\t\t? get( firstRow, [ 'cells', 'length' ] )\n\t\t\t: columnCount;\n\n\t// Bail early if the function cannot determine how many cells to add.\n\tif ( ! cellCount ) {\n\t\treturn state;\n\t}\n\n\treturn {\n\t\t[ sectionName ]: [\n\t\t\t...state[ sectionName ].slice( 0, rowIndex ),\n\t\t\t{\n\t\t\t\tcells: Array.from( { length: cellCount } ).map(\n\t\t\t\t\t( _, index ) => {\n\t\t\t\t\t\tconst firstCellInColumn = get(\n\t\t\t\t\t\t\tfirstRow,\n\t\t\t\t\t\t\t[ 'cells', index ],\n\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst inheritedAttributes = pick(\n\t\t\t\t\t\t\tfirstCellInColumn,\n\t\t\t\t\t\t\tINHERITED_COLUMN_ATTRIBUTES\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...inheritedAttributes,\n\t\t\t\t\t\t\tcontent: '',\n\t\t\t\t\t\t\ttag: sectionName === 'head' ? 'th' : 'td',\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t),\n\t\t\t},\n\t\t\t...state[ sectionName ].slice( rowIndex ),\n\t\t],\n\t};\n}\n\n/**\n * Deletes a row from the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {string} options.sectionName Section in which to delete the row.\n * @param {number} options.rowIndex    Row index to delete.\n *\n * @return {Object} New table state.\n */\nexport function deleteRow( state, { sectionName, rowIndex } ) {\n\treturn {\n\t\t[ sectionName ]: state[ sectionName ].filter(\n\t\t\t( row, index ) => index !== rowIndex\n\t\t),\n\t};\n}\n\n/**\n * Inserts a column in the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {number} options.columnIndex Column index at which to insert the column.\n *\n * @return {Object} New table state.\n */\nexport function insertColumn( state, { columnIndex } ) {\n\tconst tableSections = pick( state, [ 'head', 'body', 'foot' ] );\n\n\treturn mapValues( tableSections, ( section, sectionName ) => {\n\t\t// Bail early if the table section is empty.\n\t\tif ( isEmptyTableSection( section ) ) {\n\t\t\treturn section;\n\t\t}\n\n\t\treturn section.map( ( row ) => {\n\t\t\t// Bail early if the row is empty or it's an attempt to insert past\n\t\t\t// the last possible index of the array.\n\t\t\tif ( isEmptyRow( row ) || row.cells.length < columnIndex ) {\n\t\t\t\treturn row;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcells: [\n\t\t\t\t\t...row.cells.slice( 0, columnIndex ),\n\t\t\t\t\t{\n\t\t\t\t\t\tcontent: '',\n\t\t\t\t\t\ttag: sectionName === 'head' ? 'th' : 'td',\n\t\t\t\t\t},\n\t\t\t\t\t...row.cells.slice( columnIndex ),\n\t\t\t\t],\n\t\t\t};\n\t\t} );\n\t} );\n}\n\n/**\n * Deletes a column from the table state.\n *\n * @param {Object} state               Current table state.\n * @param {Object} options\n * @param {number} options.columnIndex Column index to delete.\n *\n * @return {Object} New table state.\n */\nexport function deleteColumn( state, { columnIndex } ) {\n\tconst tableSections = pick( state, [ 'head', 'body', 'foot' ] );\n\n\treturn mapValues( tableSections, ( section ) => {\n\t\t// Bail early if the table section is empty.\n\t\tif ( isEmptyTableSection( section ) ) {\n\t\t\treturn section;\n\t\t}\n\n\t\treturn section\n\t\t\t.map( ( row ) => ( {\n\t\t\t\tcells:\n\t\t\t\t\trow.cells.length >= columnIndex\n\t\t\t\t\t\t? row.cells.filter(\n\t\t\t\t\t\t\t\t( cell, index ) => index !== columnIndex\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: row.cells,\n\t\t\t} ) )\n\t\t\t.filter( ( row ) => row.cells.length );\n\t} );\n}\n\n/**\n * Toggles the existence of a section.\n *\n * @param {Object} state       Current table state.\n * @param {string} sectionName Name of the section to toggle.\n *\n * @return {Object} New table state.\n */\nexport function toggleSection( state, sectionName ) {\n\t// Section exists, replace it with an empty row to remove it.\n\tif ( ! isEmptyTableSection( state[ sectionName ] ) ) {\n\t\treturn { [ sectionName ]: [] };\n\t}\n\n\t// Get the length of the first row of the body to use when creating the header.\n\tconst columnCount = get( state, [ 'body', 0, 'cells', 'length' ], 1 );\n\n\t// Section doesn't exist, insert an empty row to create the section.\n\treturn insertRow( state, { sectionName, rowIndex: 0, columnCount } );\n}\n\n/**\n * Determines whether a table section is empty.\n *\n * @param {Object} section Table section state.\n *\n * @return {boolean} True if the table section is empty, false otherwise.\n */\nexport function isEmptyTableSection( section ) {\n\treturn ! section || ! section.length || section.every( isEmptyRow );\n}\n\n/**\n * Determines whether a table row is empty.\n *\n * @param {Object} row Table row state.\n *\n * @return {boolean} True if the table section is empty, false otherwise.\n */\nexport function isEmptyRow( row ) {\n\treturn ! ( row.cells && row.cells.length );\n}\n"]}
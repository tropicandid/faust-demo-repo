"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _i18n = require("@wordpress/i18n");

var _blocks = require("@wordpress/blocks");

var _components = require("@wordpress/components");

var _data = require("@wordpress/data");

var _skipToSelectedBlock = _interopRequireDefault(require("../skip-to-selected-block"));

var _blockCard = _interopRequireDefault(require("../block-card"));

var _inspectorControls = _interopRequireWildcard(require("../inspector-controls"));

var _blockStyles = _interopRequireDefault(require("../block-styles"));

var _multiSelectionInspector = _interopRequireDefault(require("../multi-selection-inspector"));

var _defaultStylePicker = _interopRequireDefault(require("../default-style-picker"));

var _blockVariationTransforms = _interopRequireDefault(require("../block-variation-transforms"));

var _useBlockDisplayInformation = _interopRequireDefault(require("../use-block-display-information"));

var _store = require("../../store");

var _blockIcon = _interopRequireDefault(require("../block-icon"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function useContentBlocks(blockTypes, block) {
  const contenBlocksObjectAux = (0, _element.useMemo)(() => {
    return blockTypes.reduce((result, blockType) => {
      if (blockType.name !== 'core/list-item' && Object.entries(blockType.attributes).some(_ref => {
        let [, {
          __experimentalRole
        }] = _ref;
        return __experimentalRole === 'content';
      })) {
        result[blockType.name] = true;
      }

      return result;
    }, {});
  }, [blockTypes]);
  const isContentBlock = (0, _element.useCallback)(blockName => {
    return !!contenBlocksObjectAux[blockName];
  }, [blockTypes]);
  return (0, _element.useMemo)(() => {
    return getContentBlocks([block], isContentBlock);
  }, [block, isContentBlock]);
}

function getContentBlocks(blocks, isContentBlock) {
  const result = [];

  for (const block of blocks) {
    if (isContentBlock(block.name)) {
      result.push(block);
    }

    result.push(...getContentBlocks(block.innerBlocks, isContentBlock));
  }

  return result;
}

function BlockNavigationButton(_ref2) {
  let {
    blockTypes,
    block,
    selectedBlock
  } = _ref2;
  const {
    selectBlock
  } = (0, _data.useDispatch)(_store.store);
  const blockType = blockTypes.find(_ref3 => {
    let {
      name
    } = _ref3;
    return name === block.name;
  });
  const isSelected = selectedBlock && selectedBlock.clientId === block.clientId;
  return (0, _element.createElement)(_components.Button, {
    isPressed: isSelected,
    onClick: () => selectBlock(block.clientId)
  }, (0, _element.createElement)(_components.__experimentalHStack, {
    justify: "flex-start"
  }, (0, _element.createElement)(_blockIcon.default, {
    icon: blockType.icon
  }), (0, _element.createElement)(_components.FlexItem, null, blockType.title)));
}

function BlockInspectorLockedBlocks(_ref4) {
  let {
    topLevelLockedBlock
  } = _ref4;
  const {
    blockTypes,
    block,
    selectedBlock
  } = (0, _data.useSelect)(select => {
    return {
      blockTypes: select(_blocks.store).getBlockTypes(),
      block: select(_store.store).getBlock(topLevelLockedBlock),
      selectedBlock: select(_store.store).getSelectedBlock()
    };
  }, [topLevelLockedBlock]);
  const blockInformation = (0, _useBlockDisplayInformation.default)(topLevelLockedBlock);
  const contentBlocks = useContentBlocks(blockTypes, block);
  return (0, _element.createElement)("div", {
    className: "block-editor-block-inspector"
  }, (0, _element.createElement)(_blockCard.default, blockInformation), (0, _element.createElement)(_blockVariationTransforms.default, {
    blockClientId: topLevelLockedBlock
  }), (0, _element.createElement)(_components.__experimentalVStack, {
    spacing: 1,
    padding: 4,
    className: "block-editor-block-inspector__block-buttons-container"
  }, (0, _element.createElement)("h2", {
    className: "block-editor-block-card__title"
  }, (0, _i18n.__)('Content')), contentBlocks.map(contentBlock => (0, _element.createElement)(BlockNavigationButton, {
    selectedBlock: selectedBlock,
    key: contentBlock.clientId,
    block: contentBlock,
    blockTypes: blockTypes
  }))));
}

const BlockInspector = _ref5 => {
  let {
    showNoBlockSelectedMessage = true
  } = _ref5;
  const {
    count,
    selectedBlockName,
    selectedBlockClientId,
    blockType,
    topLevelLockedBlock
  } = (0, _data.useSelect)(select => {
    const {
      getSelectedBlockClientId,
      getSelectedBlockCount,
      getBlockName,
      __unstableGetContentLockingParent,
      getTemplateLock
    } = select(_store.store);

    const _selectedBlockClientId = getSelectedBlockClientId();

    const _selectedBlockName = _selectedBlockClientId && getBlockName(_selectedBlockClientId);

    const _blockType = _selectedBlockName && (0, _blocks.getBlockType)(_selectedBlockName);

    return {
      count: getSelectedBlockCount(),
      selectedBlockClientId: _selectedBlockClientId,
      selectedBlockName: _selectedBlockName,
      blockType: _blockType,
      topLevelLockedBlock: __unstableGetContentLockingParent(_selectedBlockClientId) || (getTemplateLock(_selectedBlockClientId) === 'contentOnly' ? _selectedBlockClientId : undefined)
    };
  }, []);

  if (count > 1) {
    return (0, _element.createElement)("div", {
      className: "block-editor-block-inspector"
    }, (0, _element.createElement)(_multiSelectionInspector.default, null), (0, _element.createElement)(_inspectorControls.default.Slot, null), (0, _element.createElement)(_inspectorControls.default.Slot, {
      __experimentalGroup: "color",
      label: (0, _i18n.__)('Color'),
      className: "color-block-support-panel__inner-wrapper"
    }), (0, _element.createElement)(_inspectorControls.default.Slot, {
      __experimentalGroup: "typography",
      label: (0, _i18n.__)('Typography')
    }), (0, _element.createElement)(_inspectorControls.default.Slot, {
      __experimentalGroup: "dimensions",
      label: (0, _i18n.__)('Dimensions')
    }), (0, _element.createElement)(_inspectorControls.default.Slot, {
      __experimentalGroup: "border",
      label: (0, _i18n.__)('Border')
    }));
  }

  const isSelectedBlockUnregistered = selectedBlockName === (0, _blocks.getUnregisteredTypeHandlerName)();
  /*
   * If the selected block is of an unregistered type, avoid showing it as an actual selection
   * because we want the user to focus on the unregistered block warning, not block settings.
   */

  if (!blockType || !selectedBlockClientId || isSelectedBlockUnregistered) {
    if (showNoBlockSelectedMessage) {
      return (0, _element.createElement)("span", {
        className: "block-editor-block-inspector__no-blocks"
      }, (0, _i18n.__)('No block selected.'));
    }

    return null;
  }

  if (topLevelLockedBlock) {
    return (0, _element.createElement)(BlockInspectorLockedBlocks, {
      topLevelLockedBlock: topLevelLockedBlock
    });
  }

  return (0, _element.createElement)(BlockInspectorSingleBlock, {
    clientId: selectedBlockClientId,
    blockName: blockType.name
  });
};

const BlockInspectorSingleBlock = _ref6 => {
  let {
    clientId,
    blockName
  } = _ref6;
  const hasBlockStyles = (0, _data.useSelect)(select => {
    const {
      getBlockStyles
    } = select(_blocks.store);
    const blockStyles = getBlockStyles(blockName);
    return blockStyles && blockStyles.length > 0;
  }, [blockName]);
  const blockInformation = (0, _useBlockDisplayInformation.default)(clientId);
  return (0, _element.createElement)("div", {
    className: "block-editor-block-inspector"
  }, (0, _element.createElement)(_blockCard.default, blockInformation), (0, _element.createElement)(_blockVariationTransforms.default, {
    blockClientId: clientId
  }), hasBlockStyles && (0, _element.createElement)("div", null, (0, _element.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Styles')
  }, (0, _element.createElement)(_blockStyles.default, {
    clientId: clientId
  }), (0, _blocks.hasBlockSupport)(blockName, 'defaultStylePicker', true) && (0, _element.createElement)(_defaultStylePicker.default, {
    blockName: blockName
  }))), (0, _element.createElement)(_inspectorControls.default.Slot, null), (0, _element.createElement)(_inspectorControls.default.Slot, {
    __experimentalGroup: "color",
    label: (0, _i18n.__)('Color'),
    className: "color-block-support-panel__inner-wrapper"
  }), (0, _element.createElement)(_inspectorControls.default.Slot, {
    __experimentalGroup: "typography",
    label: (0, _i18n.__)('Typography')
  }), (0, _element.createElement)(_inspectorControls.default.Slot, {
    __experimentalGroup: "dimensions",
    label: (0, _i18n.__)('Dimensions')
  }), (0, _element.createElement)(_inspectorControls.default.Slot, {
    __experimentalGroup: "border",
    label: (0, _i18n.__)('Border')
  }), (0, _element.createElement)("div", null, (0, _element.createElement)(AdvancedControls, null)), (0, _element.createElement)(_skipToSelectedBlock.default, {
    key: "back"
  }));
};

const AdvancedControls = () => {
  const fills = (0, _components.__experimentalUseSlotFills)(_inspectorControls.InspectorAdvancedControls.slotName);
  const hasFills = Boolean(fills && fills.length);

  if (!hasFills) {
    return null;
  }

  return (0, _element.createElement)(_components.PanelBody, {
    className: "block-editor-block-inspector__advanced",
    title: (0, _i18n.__)('Advanced'),
    initialOpen: false
  }, (0, _element.createElement)(_inspectorControls.default.Slot, {
    __experimentalGroup: "advanced"
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-inspector/README.md
 */


var _default = BlockInspector;
exports.default = _default;
//# sourceMappingURL=index.js.map
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DIMENSIONS_SUPPORT_KEY = exports.AXIAL_SIDES = exports.ALL_SIDES = void 0;
exports.DimensionsPanel = DimensionsPanel;
exports.SPACING_SUPPORT_KEY = void 0;
exports.hasDimensionsSupport = hasDimensionsSupport;
exports.useCustomSides = useCustomSides;
exports.useIsDimensionsSupportValid = useIsDimensionsSupportValid;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _inspectorControls = _interopRequireDefault(require("../components/inspector-controls"));

var _gap = require("./gap");

var _margin = require("./margin");

var _minHeight = require("./min-height");

var _padding = require("./padding");

var _useSetting = _interopRequireDefault(require("../components/use-setting"));

var _store = require("../store");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const DIMENSIONS_SUPPORT_KEY = 'dimensions';
exports.DIMENSIONS_SUPPORT_KEY = DIMENSIONS_SUPPORT_KEY;
const SPACING_SUPPORT_KEY = 'spacing';
exports.SPACING_SUPPORT_KEY = SPACING_SUPPORT_KEY;
const ALL_SIDES = ['top', 'right', 'bottom', 'left'];
exports.ALL_SIDES = ALL_SIDES;
const AXIAL_SIDES = ['vertical', 'horizontal'];
exports.AXIAL_SIDES = AXIAL_SIDES;

function useVisualizerMouseOver() {
  const [isMouseOver, setIsMouseOver] = (0, _element.useState)(false);
  const {
    __experimentalHideBlockInterface: hideBlockInterface,
    __experimentalShowBlockInterface: showBlockInterface
  } = (0, _data.useDispatch)(_store.store);

  const onMouseOver = e => {
    e.stopPropagation();
    hideBlockInterface();
    setIsMouseOver(true);
  };

  const onMouseOut = e => {
    e.stopPropagation();
    showBlockInterface();
    setIsMouseOver(false);
  };

  return {
    isMouseOver,
    onMouseOver,
    onMouseOut
  };
}
/**
 * Inspector controls for dimensions support.
 *
 * @param {Object} props Block props.
 *
 * @return {WPElement} Inspector controls for dimensions and spacing support features.
 */


function DimensionsPanel(props) {
  const isGapDisabled = (0, _gap.useIsGapDisabled)(props);
  const isPaddingDisabled = (0, _padding.useIsPaddingDisabled)(props);
  const isMarginDisabled = (0, _margin.useIsMarginDisabled)(props);
  const isMinHeightDisabled = (0, _minHeight.useIsMinHeightDisabled)(props);
  const isDisabled = useIsDimensionsDisabled(props);
  const isSupported = hasDimensionsSupport(props.name);
  const spacingSizes = (0, _useSetting.default)('spacing.spacingSizes');
  const paddingMouseOver = useVisualizerMouseOver();
  const marginMouseOver = useVisualizerMouseOver();

  if (isDisabled || !isSupported) {
    return null;
  }

  const defaultDimensionsControls = (0, _blocks.getBlockSupport)(props.name, [DIMENSIONS_SUPPORT_KEY, '__experimentalDefaultControls']);
  const defaultSpacingControls = (0, _blocks.getBlockSupport)(props.name, [SPACING_SUPPORT_KEY, '__experimentalDefaultControls']);

  const createResetAllFilter = (attribute, featureSet) => newAttributes => {
    var _newAttributes$style;

    return { ...newAttributes,
      style: { ...newAttributes.style,
        [featureSet]: { ...((_newAttributes$style = newAttributes.style) === null || _newAttributes$style === void 0 ? void 0 : _newAttributes$style[featureSet]),
          [attribute]: undefined
        }
      }
    };
  };

  const spacingClassnames = (0, _classnames.default)({
    'tools-panel-item-spacing': spacingSizes && spacingSizes.length > 0
  });
  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_inspectorControls.default, {
    __experimentalGroup: "dimensions"
  }, !isPaddingDisabled && (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    className: spacingClassnames,
    hasValue: () => (0, _padding.hasPaddingValue)(props),
    label: (0, _i18n.__)('Padding'),
    onDeselect: () => (0, _padding.resetPadding)(props),
    resetAllFilter: createResetAllFilter('padding', 'spacing'),
    isShownByDefault: defaultSpacingControls === null || defaultSpacingControls === void 0 ? void 0 : defaultSpacingControls.padding,
    panelId: props.clientId
  }, (0, _element.createElement)(_padding.PaddingEdit, (0, _extends2.default)({
    onMouseOver: paddingMouseOver.onMouseOver,
    onMouseOut: paddingMouseOver.onMouseOut
  }, props))), !isMarginDisabled && (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    className: spacingClassnames,
    hasValue: () => (0, _margin.hasMarginValue)(props),
    label: (0, _i18n.__)('Margin'),
    onDeselect: () => (0, _margin.resetMargin)(props),
    resetAllFilter: createResetAllFilter('margin', 'spacing'),
    isShownByDefault: defaultSpacingControls === null || defaultSpacingControls === void 0 ? void 0 : defaultSpacingControls.margin,
    panelId: props.clientId
  }, (0, _element.createElement)(_margin.MarginEdit, (0, _extends2.default)({
    onMouseOver: marginMouseOver.onMouseOver,
    onMouseOut: marginMouseOver.onMouseOut
  }, props))), !isGapDisabled && (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    className: spacingClassnames,
    hasValue: () => (0, _gap.hasGapValue)(props),
    label: (0, _i18n.__)('Block spacing'),
    onDeselect: () => (0, _gap.resetGap)(props),
    resetAllFilter: createResetAllFilter('blockGap', 'spacing'),
    isShownByDefault: defaultSpacingControls === null || defaultSpacingControls === void 0 ? void 0 : defaultSpacingControls.blockGap,
    panelId: props.clientId
  }, (0, _element.createElement)(_gap.GapEdit, props)), !isMinHeightDisabled && (0, _element.createElement)(_components.__experimentalToolsPanelItem, {
    className: "single-column",
    hasValue: () => (0, _minHeight.hasMinHeightValue)(props),
    label: (0, _i18n.__)('Min. height'),
    onDeselect: () => (0, _minHeight.resetMinHeight)(props),
    resetAllFilter: createResetAllFilter('minHeight', 'dimensions'),
    isShownByDefault: defaultDimensionsControls === null || defaultDimensionsControls === void 0 ? void 0 : defaultDimensionsControls.minHeight,
    panelId: props.clientId
  }, (0, _element.createElement)(_minHeight.MinHeightEdit, props))), !isPaddingDisabled && (0, _element.createElement)(_padding.PaddingVisualizer, (0, _extends2.default)({
    forceShow: paddingMouseOver.isMouseOver
  }, props)), !isMarginDisabled && (0, _element.createElement)(_margin.MarginVisualizer, (0, _extends2.default)({
    forceShow: marginMouseOver.isMouseOver
  }, props)));
}
/**
 * Determine whether there is dimensions related block support.
 *
 * @param {string} blockName Block name.
 *
 * @return {boolean} Whether there is support.
 */


function hasDimensionsSupport(blockName) {
  if (_element.Platform.OS !== 'web') {
    return false;
  }

  return (0, _gap.hasGapSupport)(blockName) || (0, _minHeight.hasMinHeightSupport)(blockName) || (0, _padding.hasPaddingSupport)(blockName) || (0, _margin.hasMarginSupport)(blockName);
}
/**
 * Determines whether dimensions support has been disabled.
 *
 * @param {Object} props Block properties.
 *
 * @return {boolean} If spacing support is completely disabled.
 */


const useIsDimensionsDisabled = function () {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const gapDisabled = (0, _gap.useIsGapDisabled)(props);
  const minHeightDisabled = (0, _minHeight.useIsMinHeightDisabled)(props);
  const paddingDisabled = (0, _padding.useIsPaddingDisabled)(props);
  const marginDisabled = (0, _margin.useIsMarginDisabled)(props);
  return gapDisabled && minHeightDisabled && paddingDisabled && marginDisabled;
};
/**
 * Custom hook to retrieve which padding/margin/blockGap is supported
 * e.g. top, right, bottom or left.
 *
 * Sides are opted into by default. It is only if a specific side is set to
 * false that it is omitted.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   The feature custom sides relate to e.g. padding or margins.
 *
 * @return {?string[]} Strings representing the custom sides available.
 */


function useCustomSides(blockName, feature) {
  var _support$feature;

  const support = (0, _blocks.getBlockSupport)(blockName, SPACING_SUPPORT_KEY); // Skip when setting is boolean as theme isn't setting arbitrary sides.

  if (!support || typeof support[feature] === 'boolean') {
    return;
  } // Return if the setting is an array of sides (e.g. `[ 'top', 'bottom' ]`).


  if (Array.isArray(support[feature])) {
    return support[feature];
  } // Finally, attempt to return `.sides` if the setting is an object.


  if ((_support$feature = support[feature]) !== null && _support$feature !== void 0 && _support$feature.sides) {
    return support[feature].sides;
  }
}
/**
 * Custom hook to determine whether the sides configured in the
 * block support are valid. A dimension property cannot declare
 * support for a mix of axial and individual sides.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   The feature custom sides relate to e.g. padding or margins.
 *
 * @return {boolean} If the feature has a valid configuration of sides.
 */


function useIsDimensionsSupportValid(blockName, feature) {
  const sides = useCustomSides(blockName, feature);

  if (sides && sides.some(side => ALL_SIDES.includes(side)) && sides.some(side => AXIAL_SIDES.includes(side))) {
    // eslint-disable-next-line no-console
    console.warn(`The ${feature} support for the "${blockName}" block can not be configured to support both axial and arbitrary sides.`);
    return false;
  }

  return true;
}
//# sourceMappingURL=dimensions.js.map
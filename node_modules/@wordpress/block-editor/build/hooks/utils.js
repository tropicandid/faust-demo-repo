"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanEmptyObject = void 0;
exports.immutableSet = immutableSet;
exports.shouldSkipSerialization = shouldSkipSerialization;
exports.transformStyles = transformStyles;

var _lodash = require("lodash");

var _blocks = require("@wordpress/blocks");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Removed falsy values from nested object.
 *
 * @param {*} object
 * @return {*} Object cleaned from falsy values
 */
const cleanEmptyObject = object => {
  if (object === null || typeof object !== 'object' || Array.isArray(object)) {
    return object;
  }

  const cleanedNestedObjects = Object.fromEntries(Object.entries((0, _lodash.mapValues)(object, cleanEmptyObject)).filter(_ref => {
    let [, value] = _ref;
    return Boolean(value);
  }));
  return (0, _lodash.isEmpty)(cleanedNestedObjects) ? undefined : cleanedNestedObjects;
};

exports.cleanEmptyObject = cleanEmptyObject;

function immutableSet(object, path, value) {
  return (0, _lodash.setWith)(object ? (0, _lodash.clone)(object) : {}, path, value, _lodash.clone);
}

function transformStyles(activeSupports, migrationPaths, result, source, index, results) {
  var _source$;

  // If there are no active supports return early.
  if (Object.values(activeSupports !== null && activeSupports !== void 0 ? activeSupports : {}).every(isActive => !isActive)) {
    return result;
  } // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the styles should not be transformed.


  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  } // For cases where we have a transform from one block to multiple blocks
  // or multiple blocks to one block we apply the styles of the first source block
  // to the result(s).


  let referenceBlockAttributes = (_source$ = source[0]) === null || _source$ === void 0 ? void 0 : _source$.attributes; // If we are in presence of transform between more than one block in the source
  // that has more than one block in the result
  // we apply the styles on source N to the result N,
  // if source N does not exists we do nothing.

  if (results.length > 1 && source.length > 1) {
    if (source[index]) {
      var _source$index;

      referenceBlockAttributes = (_source$index = source[index]) === null || _source$index === void 0 ? void 0 : _source$index.attributes;
    } else {
      return result;
    }
  }

  let returnBlock = result;
  Object.entries(activeSupports).forEach(_ref2 => {
    let [support, isActive] = _ref2;

    if (isActive) {
      migrationPaths[support].forEach(path => {
        const styleValue = (0, _lodash.get)(referenceBlockAttributes, path);

        if (styleValue) {
          returnBlock = { ...returnBlock,
            attributes: immutableSet(returnBlock.attributes, path, styleValue)
          };
        }
      });
    }
  });
  return returnBlock;
}
/**
 * Check whether serialization of specific block support feature or set should
 * be skipped.
 *
 * @param {string|Object} blockType  Block name or block type object.
 * @param {string}        featureSet Name of block support feature set.
 * @param {string}        feature    Name of the individual feature to check.
 *
 * @return {boolean} Whether serialization should occur.
 */


function shouldSkipSerialization(blockType, featureSet, feature) {
  const support = (0, _blocks.getBlockSupport)(blockType, featureSet);
  const skipSerialization = support === null || support === void 0 ? void 0 : support.__experimentalSkipSerialization;

  if (Array.isArray(skipSerialization)) {
    return skipSerialization.includes(feature);
  }

  return skipSerialization;
}
//# sourceMappingURL=utils.js.map
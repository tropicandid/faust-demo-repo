"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FONT_FAMILY_SUPPORT_KEY = void 0;
exports.FontFamilyEdit = FontFamilyEdit;
exports.hasFontFamilyValue = hasFontFamilyValue;
exports.resetFontFamily = resetFontFamily;
exports.useIsFontFamilyDisabled = useIsFontFamilyDisabled;

var _element = require("@wordpress/element");

var _lodash = require("lodash");

var _hooks = require("@wordpress/hooks");

var _blocks = require("@wordpress/blocks");

var _tokenList = _interopRequireDefault(require("@wordpress/token-list"));

var _useSetting = _interopRequireDefault(require("../components/use-setting"));

var _fontFamily = _interopRequireDefault(require("../components/font-family"));

var _utils = require("./utils");

var _typography = require("./typography");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const FONT_FAMILY_SUPPORT_KEY = 'typography.__experimentalFontFamily';
/**
 * Filters registered block settings, extending attributes to include
 * the `fontFamily` attribute.
 *
 * @param {Object} settings Original block settings
 * @return {Object}         Filtered block settings
 */

exports.FONT_FAMILY_SUPPORT_KEY = FONT_FAMILY_SUPPORT_KEY;

function addAttributes(settings) {
  if (!(0, _blocks.hasBlockSupport)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  } // Allow blocks to specify a default value if needed.


  if (!settings.attributes.fontFamily) {
    Object.assign(settings.attributes, {
      fontFamily: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject font family.
 *
 * @param {Object} props      Additional props applied to save element
 * @param {Object} blockType  Block type
 * @param {Object} attributes Block attributes
 * @return {Object}           Filtered props applied to save element
 */


function addSaveProps(props, blockType, attributes) {
  if (!(0, _blocks.hasBlockSupport)(blockType, FONT_FAMILY_SUPPORT_KEY)) {
    return props;
  }

  if ((0, _utils.shouldSkipSerialization)(blockType, _typography.TYPOGRAPHY_SUPPORT_KEY, 'fontFamily')) {
    return props;
  }

  if (!(attributes !== null && attributes !== void 0 && attributes.fontFamily)) {
    return props;
  } // Use TokenList to dedupe classes.


  const classes = new _tokenList.default(props.className);
  classes.add(`has-${(0, _lodash.kebabCase)(attributes === null || attributes === void 0 ? void 0 : attributes.fontFamily)}-font-family`);
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to expand the block edit wrapper
 * by applying the desired styles and classnames.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function addEditProps(settings) {
  if (!(0, _blocks.hasBlockSupport)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return addSaveProps(props, settings, attributes);
  };

  return settings;
}

function FontFamilyEdit(_ref) {
  var _find;

  let {
    setAttributes,
    attributes: {
      fontFamily
    }
  } = _ref;
  const fontFamilies = (0, _useSetting.default)('typography.fontFamilies');
  const value = (_find = (0, _lodash.find)(fontFamilies, _ref2 => {
    let {
      slug
    } = _ref2;
    return fontFamily === slug;
  })) === null || _find === void 0 ? void 0 : _find.fontFamily;

  function onChange(newValue) {
    const predefinedFontFamily = (0, _lodash.find)(fontFamilies, _ref3 => {
      let {
        fontFamily: f
      } = _ref3;
      return f === newValue;
    });
    setAttributes({
      fontFamily: predefinedFontFamily === null || predefinedFontFamily === void 0 ? void 0 : predefinedFontFamily.slug
    });
  }

  return (0, _element.createElement)(_fontFamily.default, {
    className: "block-editor-hooks-font-family-control",
    fontFamilies: fontFamilies,
    value: value,
    onChange: onChange,
    size: "__unstable-large",
    __nextHasNoMarginBottom: true
  });
}
/**
 * Custom hook that checks if font-family functionality is disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */


function useIsFontFamilyDisabled(_ref4) {
  let {
    name
  } = _ref4;
  const fontFamilies = (0, _useSetting.default)('typography.fontFamilies');
  return !fontFamilies || fontFamilies.length === 0 || !(0, _blocks.hasBlockSupport)(name, FONT_FAMILY_SUPPORT_KEY);
}
/**
 * Checks if there is a current value set for the font family block support.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a font family value set.
 */


function hasFontFamilyValue(props) {
  return !!props.attributes.fontFamily;
}
/**
 * Resets the font family block support attribute. This can be used when
 * disabling the font family support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */


function resetFontFamily(_ref5) {
  let {
    setAttributes
  } = _ref5;
  setAttributes({
    fontFamily: undefined
  });
}

(0, _hooks.addFilter)('blocks.registerBlockType', 'core/fontFamily/addAttribute', addAttributes);
(0, _hooks.addFilter)('blocks.getSaveContent.extraProps', 'core/fontFamily/addSaveProps', addSaveProps);
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/fontFamily/addEditProps', addEditProps);
//# sourceMappingURL=font-family.js.map
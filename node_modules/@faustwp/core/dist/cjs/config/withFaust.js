"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withFaust = exports.addHeaders = exports.createRedirects = void 0;
const trim_js_1 = __importDefault(require("lodash/trim.js"));
const isFunction_js_1 = __importDefault(require("lodash/isFunction.js"));
async function createRedirects(nextConfig, redirectFn, previewDestination = '/preview') {
    let redirects = [];
    const previewQuery = [
        {
            type: 'query',
            key: 'preview',
            value: 'true',
        },
    ];
    if ((0, isFunction_js_1.default)(redirectFn)) {
        redirects = await redirectFn();
    }
    let previewPath = (0, trim_js_1.default)(previewDestination, '/');
    if (nextConfig === null || nextConfig === void 0 ? void 0 : nextConfig.trailingSlash) {
        previewPath += '/';
    }
    redirects.unshift({
        source: `/((?!${previewPath}).*)`,
        has: previewQuery,
        destination: `/${previewPath}`,
        permanent: false,
    });
    if (nextConfig === null || nextConfig === void 0 ? void 0 : nextConfig.i18n) {
        /**
         * All redirect sources are automatically prefixed with available locales
         * when i18n is configured, so our previous rule won't match '/'. We need
         * an extra rule to catch each locale's root path.
         *
         * https://nextjs.org/docs/api-reference/next.config.js/redirects#redirects-with-i18n-support
         */
        redirects.unshift({
            source: nextConfig.trailingSlash ? '/:lang/' : '/:lang',
            has: previewQuery,
            destination: `/:lang/${previewPath}`,
            permanent: false,
            locale: false,
        });
    }
    return redirects;
}
exports.createRedirects = createRedirects;
async function addHeaders(nextConfig, existingHeaders) {
    let headers = [];
    if ((0, isFunction_js_1.default)(existingHeaders)) {
        headers = await existingHeaders();
    }
    headers.push({
        source: '/:path*',
        headers: [
            {
                key: 'x-using',
                value: 'faust',
            },
        ],
    });
    return headers;
}
exports.addHeaders = addHeaders;
/**
 * A helper function to merge Faust related Next.js config with a user defined Next.js config.
 *
 * @param {NextConfig} exportedUserNextConfig The existing config to be exported prior to adding Faust
 * @param {WithFaustConfig} withFaustConfig The Configuration for Faust
 * @returns {NextConfig} The modified config to be exported
 */
function withFaust(exportedUserNextConfig, withFaustConfig) {
    const nextConfig = exportedUserNextConfig !== null && exportedUserNextConfig !== void 0 ? exportedUserNextConfig : {};
    const { previewDestination } = withFaustConfig || {};
    const existingRedirects = nextConfig.redirects;
    nextConfig.redirects = () => createRedirects(nextConfig, existingRedirects, previewDestination);
    const existingHeaders = nextConfig.headers;
    nextConfig.headers = () => addHeaders(nextConfig, existingHeaders);
    nextConfig.poweredByHeader = false;
    return nextConfig;
}
exports.withFaust = withFaust;

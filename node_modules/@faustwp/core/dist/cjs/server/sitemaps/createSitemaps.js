"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSitemapPath = exports.createPagesSitemap = exports.createRootSitemapIndex = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const isArray_js_1 = __importDefault(require("lodash/isArray.js"));
const isUndefined_js_1 = __importDefault(require("lodash/isUndefined.js"));
const trim_js_1 = __importDefault(require("lodash/trim.js"));
const getWpUrl_js_1 = require("../../lib/getWpUrl.js");
const getSitemapProps_js_1 = require("./getSitemapProps.js");
const sitemapUtils_js_1 = require("./sitemapUtils.js");
const parserConfig = {
    ignoreAttributes: false,
    preserveOrder: false,
    unpairedTags: ['xml', 'xml-stylesheet'],
    processEntities: true,
    htmlEntities: true,
};
/**
 * Creates the root XML sitemap index (e.g. /sitemap.xml) that lists all the
 * sitemaps provided as the sitemapPaths property in the config, in addition to
 * a sitemap for the Next.js pages provided as the pages property in the config.
 *
 * @param {NextRequest} req The Next.js request object
 * @param {NormalizedConfig} normalizedConfig A normalized config object
 * @returns {Response|undefined}
 */
async function createRootSitemapIndex(req, config) {
    var _a;
    const { pages, sitemapPathsToIgnore, frontendUrl } = config;
    if (!req.url) {
        throw new Error('Request object must have URL');
    }
    // get sitemapIndexPath config param
    // fetch sitemap from WP
    const trimmedWpUrl = (0, trim_js_1.default)((0, getWpUrl_js_1.getWpUrl)(), '/');
    const trimmedFrontendUrl = (0, trim_js_1.default)(frontendUrl, '/');
    const trimmedSitemapIndexPath = (0, trim_js_1.default)(getSitemapProps_js_1.SITEMAP_INDEX_PATH, '/');
    const wpSitemapUrl = `${trimmedWpUrl}/${trimmedSitemapIndexPath}`;
    let sitemaps = [];
    if (!(0, isUndefined_js_1.default)(pages) && (0, isArray_js_1.default)(pages) && pages.length) {
        const trimmedFaustPagesPart = `${(0, trim_js_1.default)(getSitemapProps_js_1.SITEMAP_INDEX_PATH, '/')}?sitemap=${(0, trim_js_1.default)(getSitemapProps_js_1.FAUST_PAGES_PATHNAME, '/')}`;
        const sitemapFaustPagesUrl = `${trimmedFrontendUrl}/${trimmedFaustPagesPart}`;
        sitemaps = [
            ...sitemaps,
            {
                loc: encodeURI(sitemapFaustPagesUrl),
            },
        ];
    }
    const res = await fetch(wpSitemapUrl);
    // Don't proxy the sitemap index if the response was not ok.
    if (!res.ok) {
        return undefined;
    }
    const xmlRes = await res.text();
    /**
     * Create a parser to convert our XML data into a JS object
     *
     * @link https://github.com/NaturalIntelligence/fast-xml-parser/blob/HEAD/docs/v4/6.HTMLParsing.md
     */
    const parser = new fast_xml_parser_1.XMLParser(Object.assign(Object.assign({}, parserConfig), { 
        /**
         * FXP can not determine if a single tag should be parsed as an array or
         * an object, so we need to specify we always want "sitemap" tags to be an
         * array.
         *
         * @see https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#isarray
         */
        isArray: (tagName) => {
            return tagName === 'sitemap';
        } }));
    // JS object representation of the XML sitemap index
    const parsedSitemapIndex = parser.parse(xmlRes);
    let wpSitemaps = (_a = parsedSitemapIndex === null || parsedSitemapIndex === void 0 ? void 0 : parsedSitemapIndex.sitemapindex) === null || _a === void 0 ? void 0 : _a.sitemap;
    // The XML we parsed was not a proper sitemap
    if ((0, isUndefined_js_1.default)(wpSitemaps)) {
        return undefined;
    }
    /**
     * Ignore paths with exact matches to the sitemapPathsToIgnore property
     */
    wpSitemaps = wpSitemaps.filter((sitemap) => {
        const { pathname: sitemapPathname } = new URL(sitemap.loc);
        return !(sitemapPathsToIgnore === null || sitemapPathsToIgnore === void 0 ? void 0 : sitemapPathsToIgnore.includes(sitemapPathname));
    });
    /**
     * Ignore paths from sitemapPathsToIgnore property that end in a wildcard
     */
    const wildcardPathsToIgnore = sitemapPathsToIgnore === null || sitemapPathsToIgnore === void 0 ? void 0 : sitemapPathsToIgnore.filter((path) => path.endsWith('*'));
    wpSitemaps = wpSitemaps.filter((sitemap) => {
        const { pathname: sitemapPathname } = new URL(sitemap.loc);
        let hasWildcard = false;
        wildcardPathsToIgnore === null || wildcardPathsToIgnore === void 0 ? void 0 : wildcardPathsToIgnore.forEach((path) => {
            const pathLessWildcard = path.slice(0, -1);
            if (sitemapPathname.startsWith(pathLessWildcard)) {
                hasWildcard = true;
            }
        });
        return !hasWildcard;
    });
    /**
     * Replace the existing WordPress URL in each "loc" with the frontend URL
     *
     * @example
     * Replaces http://headless.local/wp-sitemap-posts-page-1.xml with
     * http://localhost:3000/wp-sitemap-posts-page-1.xml
     */
    wpSitemaps.forEach((sitemap) => {
        const url = new URL(sitemap.loc);
        const sitemapUrl = `${(0, trim_js_1.default)(frontendUrl, '/')}/sitemap.xml?sitemap=${(0, trim_js_1.default)(url.pathname, '/')}`;
        sitemaps = [
            ...sitemaps,
            Object.assign(Object.assign({}, sitemap), { loc: sitemapUrl }),
        ];
    });
    return (0, sitemapUtils_js_1.createSitemapIndex)(sitemaps);
}
exports.createRootSitemapIndex = createRootSitemapIndex;
/**
 * Creates a sitemap for the Next.js pages specified in the "pages" config option
 *
 * @param req The Next.js middleware request object
 * @param config The config object
 * @returns {Response|undefined}
 */
function createPagesSitemap(req, config) {
    if (!req.url) {
        throw new Error('Request object must have URL');
    }
    const { frontendUrl, pages } = config;
    if ((0, isUndefined_js_1.default)(pages) || !(0, isArray_js_1.default)(pages) || !pages.length) {
        return undefined;
    }
    let urls = [];
    pages.forEach((page) => {
        urls = [
            ...urls,
            {
                loc: `${(0, trim_js_1.default)(frontendUrl, '/')}/${(0, trim_js_1.default)(page.path, '/')}`,
                lastmod: page === null || page === void 0 ? void 0 : page.lastmod,
                changefreq: page === null || page === void 0 ? void 0 : page.changefreq,
                priority: page === null || page === void 0 ? void 0 : page.priority,
            },
        ];
    });
    return (0, sitemapUtils_js_1.createSitemap)(urls);
}
exports.createPagesSitemap = createPagesSitemap;
/**
 * Handles a request to a sitemap path listed in the sitemapPaths config option
 *
 * @param req The Next.js middleware request object
 * @param config The config object
 * @returns {Promise<Response|Undefined>}
 */
async function handleSitemapPath(req, config) {
    var _a;
    if (!req.url) {
        throw new Error('Request object must have URL');
    }
    const { frontendUrl } = config;
    const paramsIndex = req.url.indexOf('?');
    const searchParamString = req.url.substr(paramsIndex);
    const urlParams = new URLSearchParams(searchParamString);
    const sitemapPath = urlParams.get('sitemap');
    const wpSitemapUrl = `${(0, trim_js_1.default)((0, getWpUrl_js_1.getWpUrl)(), '/')}/${(0, trim_js_1.default)(sitemapPath, '/')}`;
    const res = await fetch(wpSitemapUrl);
    // Don't proxy the sitemap if the response was not ok.
    if (!res.ok) {
        return undefined;
    }
    const xmlRes = await res.text();
    /**
     * Create a parser to convert our XML data into a JS object
     *
     * @link https://github.com/NaturalIntelligence/fast-xml-parser/blob/HEAD/docs/v4/6.HTMLParsing.md
     */
    const parser = new fast_xml_parser_1.XMLParser(Object.assign(Object.assign({}, parserConfig), { 
        /**
         * FXP can not determine if a single tag should be parsed as an array or
         * an object, so we need to specify we always want "url" tags to be an
         * array.
         *
         * @see https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#isarray
         */
        isArray: (tagName) => {
            return tagName === 'url';
        } }));
    // JS object representation of the XML sitemap
    const parsedSitemap = parser.parse(xmlRes);
    const wpSitemapUrls = (_a = parsedSitemap === null || parsedSitemap === void 0 ? void 0 : parsedSitemap.urlset) === null || _a === void 0 ? void 0 : _a.url;
    // The XML we parsed was not a proper sitemap
    if ((0, isUndefined_js_1.default)(wpSitemapUrls)) {
        return undefined;
    }
    let urls = [];
    /**
     * Replace the existing WordPress URL in each "loc" with the headless URL
     *
     * @example
     * Replaces http://headless.local/wp-sitemap-posts-page-1.xml with
     * http://localhost:3000/wp-sitemap-posts-page-1.xml
     */
    wpSitemapUrls.forEach((url) => {
        urls = [
            ...urls,
            Object.assign(Object.assign({}, url), { loc: url.loc.replace((0, trim_js_1.default)((0, getWpUrl_js_1.getWpUrl)(), '/'), (0, trim_js_1.default)(frontendUrl, '/')) }),
        ];
    });
    return (0, sitemapUtils_js_1.createSitemap)(urls);
}
exports.handleSitemapPath = handleSitemapPath;

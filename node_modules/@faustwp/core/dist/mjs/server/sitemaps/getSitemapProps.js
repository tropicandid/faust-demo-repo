import isUndefined from 'lodash/isUndefined.js';
import isString from 'lodash/isString.js';
import isArray from 'lodash/isArray.js';
import isObject from 'lodash/isObject.js';
import { getQueryParam } from '../../utils/convert.js';
import { createPagesSitemap, createRootSitemapIndex, handleSitemapPath, } from './createSitemaps.js';
/**
 * The pathname to the root sitemap index.
 */
export const SITEMAP_INDEX_PATH = '/sitemap.xml';
/**
 * The pathname to the Next.js pages sitemap file. We may want to make this
 * configurable in the future.
 */
export const FAUST_PAGES_PATHNAME = '/sitemap-faust-pages.xml';
/**
 * Validates the structure of the user defined config.
 *
 * @param {Partial<HandleSitemapRequestsConfig>} config The user provided config
 */
export function validateConfig(config) {
    var _a, _b;
    if (!isString(config === null || config === void 0 ? void 0 : config.frontendUrl)) {
        throw new Error('frontendUrl must be a string');
    }
    try {
        // eslint-disable-next-line no-new
        const url = new URL(config.frontendUrl);
        if (url.protocol !== 'http:' && url.protocol !== 'https:') {
            throw new Error('URL must have protocol');
        }
    }
    catch (e) {
        throw new Error('frontendUrl must be a valid URL.');
    }
    if (!isUndefined(config === null || config === void 0 ? void 0 : config.sitemapPathsToIgnore)) {
        if (!isArray(config.sitemapPathsToIgnore)) {
            throw new Error('sitemapPathsToIgnore must be an array');
        }
        (_a = config === null || config === void 0 ? void 0 : config.sitemapPathsToIgnore) === null || _a === void 0 ? void 0 : _a.forEach((path) => {
            if (!isString(path)) {
                throw new Error('sitemapPathsToIgnore must be an array of strings');
            }
            if (!path.startsWith('/')) {
                throw new Error('Each sitemapPathsToIgnore must start with a forward slash');
            }
            if (path.includes('*') && !path.endsWith('*')) {
                throw new Error('sitemapPathsToIgnore with a wildcard must end with a wildcard');
            }
        });
    }
    // Validate pages structure and required values
    if (!isUndefined(config === null || config === void 0 ? void 0 : config.pages)) {
        if (!isArray(config.pages)) {
            throw new Error('pages must be an array');
        }
        (_b = config === null || config === void 0 ? void 0 : config.pages) === null || _b === void 0 ? void 0 : _b.forEach((page) => {
            if (!isObject(page)) {
                throw new Error('pages must be an array of objects');
            }
            if (isUndefined(page.path)) {
                throw new Error('pages must have a path property');
            }
            if (!isString(page.path)) {
                throw new Error('The pages path property must be a string');
            }
        });
    }
}
export async function getSitemapProps(ctx, config) {
    // config validation with middleware flag
    validateConfig(config);
    if (!ctx.req.url) {
        throw new Error('A context url is required.');
    }
    const queryParam = getQueryParam(ctx.req.url, 'sitemap');
    if (queryParam === '') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const response = await createRootSitemapIndex(ctx.req, config);
        if (!response || (response === null || response === void 0 ? void 0 : response.status) === 404) {
            return {
                notFound: true,
            };
        }
        ctx.res.setHeader('Content-Type', 'application/xml');
        ctx.res.write(await (response === null || response === void 0 ? void 0 : response.text()));
        ctx.res.end();
    }
    if (queryParam !== '' && queryParam !== 'sitemap-faust-pages.xml') {
        const response = await handleSitemapPath(ctx.req, config);
        if (!response || (response === null || response === void 0 ? void 0 : response.status) === 404) {
            return {
                notFound: true,
            };
        }
        ctx.res.setHeader('Content-Type', 'application/xml');
        ctx.res.write(await (response === null || response === void 0 ? void 0 : response.text()));
        ctx.res.end();
    }
    if (queryParam !== '' && queryParam === 'sitemap-faust-pages.xml') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const response = createPagesSitemap(ctx.req, config);
        ctx.res.setHeader('Content-Type', 'application/xml');
        ctx.res.write(await (response === null || response === void 0 ? void 0 : response.text()));
        ctx.res.end();
    }
    return {
        props: {},
    };
}
